---
title: "Pharmacokineitc Model"
---

```{r libs}
library(bayesplot)
library(here)
library(Metrics)
library(patchwork)
library(rstan)
library(tidyverse)
library(tidybayes)

# Allows Stan to run in parallel
options(mc.cores = parallel::detectCores())
# Automatically write compiled models to avoid recompilation
rstan_options(auto_write = TRUE)
theme_set(theme_minimal())
```


```{r prior_predictive_checks}

# Load the prior predictive check as a model in Stan
# We can draw from this to evaluate priors
prior_model_location = here('analysis','models','prior_predictive_check.stan')
prior_model = stan_model(prior_model_location)

# Pass to prior.  Times at which we evaluate the concentration function
ts = seq(0.5, 12, 0.1)

# Parameters for the prior.
# Passing as a list makes for easier iteration
# See model for parameter interpretations
prior_params = list(
  N = length(ts),
  t = ts,
  # Prior hyperparams for clearance
  # Control the mean and standard deviation for priors for clearance
  # easier to iterate than hardcoding in the .stan
  MU_CL_MEAN = log(log(3.3)),
  MU_CL_SIGMA = 0.25,
  S_CL_A = 15,
  S_CL_B = 100,
  # Prior hyperparams for tmax
  MU_T_MEAN = log(3.3),
  MU_T_SIGMA = 0.25,
  S_T_A = 10,
  S_T_B = 100,
  # Prior hyperparams for delay
  PHI_A = 20,
  PHI_B = 20,
  KAPPA_A = 20,
  KAPPA_B = 20,
  # Prior hyperparams for noise
  SIGMA_MEAN = log(0.2),
  SIGMA_SIGMA = 0.2
)

# Sample from the prior
prior_samples = sampling(prior_model, 
                         data = prior_params, 
                         algorithm='Fixed_param',
                         chains=1,
                         iter=2000)


# Plot the prior
units<-function(x){
  glue::glue('{x} ng/ml')
}

sampled_times = tibble(i = seq_along(ts), t = ts)
prior_samples %>% 
  spread_draws(y[i]) %>% 
  left_join(sampled_times) %>% 
  ggplot(aes(t, 1000*y, group = .draw))+
  geom_line(alpha = 0.05)+
  scale_y_continuous(labels = units)+
  ylab('Concentration')

```


```{r model}
model_location = here('analysis','models','model.stan')
model = stan_model(model_location)

data_location = here('analysis','data','apixiban_regression_data.csv')
d = read_csv(data_location) %>% 
    mutate(i = seq_along(Concentration)) # WIll use to join to results later

# Prepare data to be sent to Stan
# Model operates in units mg/L
# When I get the concentrations back, I can convert to ng/ml
# by mutiplying by 1000
model_data = list(
  yobs = d$Concentration_scaled,
  subjectids = as.integer(factor(d$Subject)),
  n_subjects = 36,
  times = d$Time,
  N = nrow(d),
  ppc_t = c(0.5, 1.0, 2.0, 4.0, 6.0, 8.0, 10.0, 12.0)
)


fit = sampling(model,
               model_data, 
               chains = 12, 
               warmup = 2000, 
               iter = 4000)

```



```{r bayes_in_3}
# Recreate the "bayes in 3 plots" figure from the paper 
prior_plot<-prior_samples %>% 
  spread_draws(y[i], n = 250, seed = 1) %>% 
  left_join(sampled_times) %>% 
  ggplot(aes(t, 1000*y, group = .draw))+
  geom_line(alpha = 0.2)+
  labs(x = 'Hours Post Dose',
       y = 'Concentration (ng/ml)',
       subtitle = 'Plausible Concentrations\nBefore Seeing Data')+
  ylim(0,250)+
  theme(aspect.ratio = 1)


error = fit %>% 
  spread_draws(C[i], n = 2000) %>% 
  mean_qi() %>% 
  left_join(d) %>% 
  ungroup %>% 
  select(Subject, C, Concentration_scaled) %>% 
  group_by(Subject) %>% 
  summarise(mape = mape(1000*Concentration_scaled, 1000*C)) %>% 
  arrange(desc(mape))

candidate = rbind(head(error,1), tail(error,1))
candidate$Rank = c('Worst Fit', 'Best Fit')
best_worst_data = d %>% 
  left_join(candidate) %>% 
  filter(Subject %in% candidate$Subject)

data_plot =  best_worst_data %>% 
  ggplot(aes(Time, Concentration))+
  geom_point(aes(fill = Rank), shape = 21, size = 2)+
  scale_fill_brewer(palette = 'Set1', direction = -1)+
  guides(fill = F)+
  labs(x = 'Time Post Dose',
       y = 'Concentration (ng/ml)',
       subtitle = 'Observed Concentration')+
  theme(aspect.ratio = 1)+
  ylim(0,250)


posterior_plot = fit %>% 
  spread_draws(C[i], n = 125, seed = 0) %>% 
  inner_join(d) %>% 
  inner_join(candidate, by = 'Subject') %>% 
  ggplot(aes(Time, 1000*C, color = Rank, group = interaction(.draw, Rank)))+
  geom_line(alpha = 0.2)+
  geom_point(data = best_worst_data,
             aes(Time, Concentration, fill = Rank),
             shape = 21,
             size = 2,
             inherit.aes = F)+
  scale_fill_brewer(palette = 'Set1', direction = -1)+
  scale_color_brewer(palette = 'Set1', direction = -1)+
  theme(aspect.ratio = 1,
        legend.position = c(0.8, 0.8))+
  ylim(0,250)+
  labs(x = 'Time Post Dose',
       y = 'Concentration (ng/ml)',
       subtitle = 'Plausible Concentrations\nAfter Seeing Data',
       color = '',
       fill = '')


prior_plot + data_plot + posterior_plot

```


```{r diagnostics}
#Make diagnostic plots for the model
#Figure found in paper
pop_obs = fit %>% 
  spread_draws(pop_obs[i]) %>% 
  mutate(pop_obs = 1000*pop_obs) %>% 
  mean_qi(.width = c(0.5, 0.8, 0.95)) %>% 
  mutate(.width = scales::percent(.width))

ppc_plot = pop_obs %>%
  left_join(d) %>% 
  ggplot()+
  geom_interval(aes(Time, ymin = .lower, ymax = .upper, color = factor(.width)))+
  geom_jitter(data = d, aes(Time, Concentration), height = 0, width = 0.2, alpha = 0.25)+
  scale_color_brewer(palette = 'OrRd', direction = -1)+
  labs(x = 'Time Post Dose', y = 'Concentration (ng/ml)', color = 'Posterior Probability')+
  theme(legend.position = c(0.75, 0.8))+
  theme(aspect.ratio = 1)+
  guides(color = guide_legend(reverse = TRUE))


resids = fit %>% 
  spread_draws(C[i]) %>% 
  mutate(log_C = log(1000*C)) %>% 
  mean_qi() %>% 
  left_join(d) %>% 
  mutate(err = log(Concentration) - log_C)


err_plot = resids %>% 
  ggplot(aes(log_C, err))+
  geom_point(size = 2, fill = 'gray', shape = 21)+
  geom_hline(aes(yintercept = 0))+
  geom_smooth(color = 'red', se = F, size = 1)+
  labs(x = 'Predicted Log Concentration', y = 'Residual on Log Scale')+
  theme(aspect.ratio = 1)

pred_plot = fit %>% 
  spread_draws(C[i]) %>% 
  mutate(C = 1000*C) %>% 
  mean_qi() %>% 
  left_join(d) %>% 
  ggplot(aes(Concentration, C, ymin = .lower, ymax = .upper))+
  geom_abline(color = 'black')+
  geom_pointrange(alpha = 0.5, color = 'black', fill = 'gray', shape = 21, size = 0.25)+
  theme(aspect.ratio = 1)+
  labs(x = 'True Concentration (ng/ml)', y = 'Predicted Concentration (ng/ml)')

  
ecdf_plot = fit %>% 
  spread_draws(ppc_C[i], n = 100) %>% 
  ungroup %>% 
  mutate(C = 1000*ppc_C) %>% 
  select(C, .draw) %>% 
  ggplot(aes(C, group = .draw))+
  stat_ecdf(aes(color = 'Posterior Concentrations'), size = 1)+
  stat_ecdf(data = d, aes(Concentration, color = 'Observed Concentration'), inherit.aes = F, size = 1)+
  scale_color_manual(values = c('black','gray'))+
  theme(aspect.ratio = 1,
        legend.position = c(0.75, 0.75))+
  labs(x = 'Concentration (ng/ml)', y = 'Cumulative Probability', color = '')
  



((ppc_plot | pred_plot) / (err_plot | ecdf_plot))

```


```{r posterior_predictive_by_subject}

fit %>% 
  spread_draws(C[i], n = 20) %>% 
  left_join(d) %>% 
  ggplot()+
  geom_line(aes(Time, C, group = .draw, color = 'Model'), alpha = 0.1)+
  geom_point(aes(Time, Concentration_scaled, color = 'Observed'), size = 0.5)+
  facet_wrap(~Subject, scales = 'free_y')+
  scale_color_manual(values = c('red','black'))
```


```{r generate_pseudodata}

#Generate the pseudodata to be made in the next step
N_subjects = 250

#Times at which to observe the subjects.
#Will splice intro train and test later
sample_times = seq(0.5, 12, 0.25)
ids = 1:N_subjects
#Easy way to get all times for all patients.
pairs = crossing(ids, sample_times) 

#Prepare model data
subjectids = pairs$ids
times = pairs$sample_times
N = length(times)

model_data = list(N = N, times = times, subjectids = subjectids, N_subjects = N_subjects)

model_location = here('analysis','models','generate_pseudo_data.stan')
model = stan_model(model_location)
fits = sampling(model, 
                data = model_data, 
                iter=1, 
                chains=1, 
                algorithm='Fixed_param',
                seed=19920908)


samples = rstan::extract(fits)

saveRDS(samples, here('analysis','data','simulated_data.RDS'))


# Will need the true pk parameters at the final step to compute calibration.
# Save in a csv.
data = tibble(
  subjectids = subjectids,
  times = times,
  C = as.numeric(samples$C),
  Cobs = as.numeric(samples$Cobs),
) %>% 
  left_join(
    tibble(subjectids=unique(subjectids), 
           tmax = as.numeric(samples$tmax),
           cl= as.numeric(samples$Cl),
           ke = as.numeric(samples$ke),
           ka = as.numeric(samples$ka),
           alpha = as.numeric(samples$alpha)),
  )


write_csv(data, here('analysis','data','simulated_data.csv'))

```



